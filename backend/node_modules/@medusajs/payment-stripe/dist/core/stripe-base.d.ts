import Stripe from "stripe";
import { AuthorizePaymentInput, AuthorizePaymentOutput, CancelPaymentInput, CancelPaymentOutput, CapturePaymentInput, CapturePaymentOutput, CreateAccountHolderInput, CreateAccountHolderOutput, DeleteAccountHolderInput, DeleteAccountHolderOutput, DeletePaymentInput, DeletePaymentOutput, GetPaymentStatusInput, GetPaymentStatusOutput, InitiatePaymentInput, InitiatePaymentOutput, ListPaymentMethodsInput, ListPaymentMethodsOutput, ProviderWebhookPayload, RefundPaymentInput, RefundPaymentOutput, RetrievePaymentInput, RetrievePaymentOutput, SavePaymentMethodInput, SavePaymentMethodOutput, UpdateAccountHolderInput, UpdateAccountHolderOutput, UpdatePaymentInput, UpdatePaymentOutput, WebhookActionResult } from "@medusajs/framework/types";
import { AbstractPaymentProvider } from "@medusajs/framework/utils";
import { PaymentIntentOptions, StripeOptions } from "../types";
type StripeIndeterminateState = {
    indeterminate_due_to: string;
};
type StripeErrorData = Stripe.PaymentIntent | StripeIndeterminateState;
type HandledErrorType = {
    retry: true;
} | {
    retry: false;
    data: StripeErrorData;
};
declare abstract class StripeBase extends AbstractPaymentProvider<StripeOptions> {
    protected readonly options_: StripeOptions;
    protected stripe_: Stripe;
    protected container_: Record<string, unknown>;
    static validateOptions(options: StripeOptions): void;
    protected constructor(cradle: Record<string, unknown>, options: StripeOptions);
    abstract get paymentIntentOptions(): PaymentIntentOptions;
    get options(): StripeOptions;
    normalizePaymentIntentParameters(extra?: Record<string, unknown>): Partial<Stripe.PaymentIntentCreateParams>;
    handleStripeError(error: any): HandledErrorType;
    executeWithRetry<T>(apiCall: () => Promise<T>, maxRetries?: number, baseDelay?: number, currentAttempt?: number): Promise<T | StripeErrorData>;
    getPaymentStatus(input: GetPaymentStatusInput): Promise<GetPaymentStatusOutput>;
    initiatePayment({ currency_code, amount, data, context, }: InitiatePaymentInput): Promise<InitiatePaymentOutput>;
    authorizePayment(input: AuthorizePaymentInput): Promise<AuthorizePaymentOutput>;
    cancelPayment({ data, context, }: CancelPaymentInput): Promise<CancelPaymentOutput>;
    capturePayment({ data, context, }: CapturePaymentInput): Promise<CapturePaymentOutput>;
    deletePayment(input: DeletePaymentInput): Promise<DeletePaymentOutput>;
    refundPayment({ amount, data, context, }: RefundPaymentInput): Promise<RefundPaymentOutput>;
    retrievePayment({ data, }: RetrievePaymentInput): Promise<RetrievePaymentOutput>;
    updatePayment({ data, currency_code, amount, context, }: UpdatePaymentInput): Promise<UpdatePaymentOutput>;
    createAccountHolder({ context, }: CreateAccountHolderInput): Promise<CreateAccountHolderOutput>;
    updateAccountHolder({ context, }: UpdateAccountHolderInput): Promise<UpdateAccountHolderOutput>;
    deleteAccountHolder({ context, }: DeleteAccountHolderInput): Promise<DeleteAccountHolderOutput>;
    listPaymentMethods({ context, }: ListPaymentMethodsInput): Promise<ListPaymentMethodsOutput>;
    savePaymentMethod({ context, data, }: SavePaymentMethodInput): Promise<SavePaymentMethodOutput>;
    private getStatus;
    getWebhookActionAndData(webhookData: ProviderWebhookPayload["payload"]): Promise<WebhookActionResult>;
    /**
     * Constructs Stripe Webhook event
     * @param {object} data - the data of the webhook request: req.body
     *    ensures integrity of the webhook event
     * @return {object} Stripe Webhook event
     */
    constructWebhookEvent(data: ProviderWebhookPayload["payload"]): Stripe.Event;
    protected buildError(message: string, error: Error): Error;
}
export default StripeBase;
//# sourceMappingURL=stripe-base.d.ts.map