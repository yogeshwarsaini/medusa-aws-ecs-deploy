"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPaymentSessionsWorkflow = exports.createPaymentSessionsWorkflowId = void 0;
const utils_1 = require("@medusajs/framework/utils");
const workflows_sdk_1 = require("@medusajs/framework/workflows-sdk");
const common_1 = require("../../common");
const steps_1 = require("../steps");
const delete_payment_sessions_1 = require("./delete-payment-sessions");
exports.createPaymentSessionsWorkflowId = "create-payment-sessions";
/**
 * This workflow creates payment sessions. It's used by the
 * [Initialize Payment Session Store API Route](https://docs.medusajs.com/api/store#payment-collections_postpaymentcollectionsidpaymentsessions).
 *
 * You can use this workflow within your own customizations or custom workflows, allowing you
 * to create payment sessions in your custom flows.
 *
 * @example
 * const { result } = await createPaymentSessionsWorkflow(container)
 * .run({
 *   input: {
 *     payment_collection_id: "paycol_123",
 *     provider_id: "pp_system"
 *   }
 * })
 *
 * @summary
 *
 * Create payment sessions.
 */
exports.createPaymentSessionsWorkflow = (0, workflows_sdk_1.createWorkflow)(exports.createPaymentSessionsWorkflowId, (input) => {
    const paymentCollection = (0, common_1.useRemoteQueryStep)({
        entry_point: "payment_collection",
        fields: ["id", "amount", "currency_code", "payment_sessions.*"],
        variables: { id: input.payment_collection_id },
        list: false,
    }).config({ name: "get-payment-collection" });
    const { paymentCustomer, accountHolder, existingAccountHolder } = (0, workflows_sdk_1.when)("customer-id-exists", { input }, (data) => {
        return !!data.input.customer_id;
    }).then(() => {
        const customer = (0, common_1.useRemoteQueryStep)({
            entry_point: "customer",
            fields: [
                "id",
                "email",
                "company_name",
                "first_name",
                "last_name",
                "phone",
                "addresses.*",
                "account_holders.*",
                "metadata",
            ],
            variables: { id: input.customer_id },
            list: false,
        }).config({ name: "get-customer" });
        const paymentCustomer = (0, workflows_sdk_1.transform)({ customer }, (data) => {
            return {
                ...data.customer,
                billing_address: data.customer.addresses?.find((a) => a.is_default_billing) ??
                    data.customer.addresses?.[0],
            };
        });
        const existingAccountHolder = (0, workflows_sdk_1.transform)({ customer, input }, (data) => {
            return data.customer.account_holders.find((ac) => ac.provider_id === data.input.provider_id);
        });
        const accountHolderInput = (0, workflows_sdk_1.transform)({ existingAccountHolder, input, paymentCustomer }, (data) => {
            return {
                provider_id: data.input.provider_id,
                context: {
                    // The module is idempotent, so if there already is a linked account holder, the module will simply return it back.
                    account_holder: data.existingAccountHolder,
                    customer: data.paymentCustomer,
                },
            };
        });
        const accountHolder = (0, steps_1.createPaymentAccountHolderStep)(accountHolderInput);
        return { paymentCustomer, accountHolder, existingAccountHolder };
    });
    (0, workflows_sdk_1.when)("account-holder-created", { paymentCustomer, accountHolder, input, existingAccountHolder }, ({ existingAccountHolder, accountHolder }) => {
        return !(0, utils_1.isPresent)(existingAccountHolder) && (0, utils_1.isPresent)(accountHolder);
    }).then(() => {
        (0, common_1.createRemoteLinkStep)([
            {
                [utils_1.Modules.CUSTOMER]: {
                    customer_id: paymentCustomer.id,
                },
                [utils_1.Modules.PAYMENT]: {
                    account_holder_id: accountHolder.id,
                },
            },
        ]);
    });
    const paymentSessionInput = (0, workflows_sdk_1.transform)({ paymentCollection, paymentCustomer, accountHolder, input }, (data) => {
        return {
            payment_collection_id: data.input.payment_collection_id,
            provider_id: data.input.provider_id,
            data: data.input.data,
            context: {
                ...data.input.context,
                customer: data.paymentCustomer,
                account_holder: data.accountHolder,
            },
            amount: data.paymentCollection.amount,
            currency_code: data.paymentCollection.currency_code,
        };
    });
    const deletePaymentSessionInput = (0, workflows_sdk_1.transform)({ paymentCollection }, (data) => {
        return {
            ids: data.paymentCollection?.payment_sessions?.map((ps) => ps.id) || [],
        };
    });
    // Note: We are deleting an existing active session before creating a new one
    // for a payment collection as we don't support split payments at the moment.
    // When we are ready to accept split payments, this along with other workflows
    // need to be handled correctly
    const [created] = (0, workflows_sdk_1.parallelize)((0, steps_1.createPaymentSessionStep)(paymentSessionInput), delete_payment_sessions_1.deletePaymentSessionsWorkflow.runAsStep({
        input: deletePaymentSessionInput,
    }));
    return new workflows_sdk_1.WorkflowResponse(created);
});
//# sourceMappingURL=create-payment-session.js.map