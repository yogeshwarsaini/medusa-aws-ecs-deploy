"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveValue = resolveValue;
const utils_1 = require("@medusajs/utils");
async function resolveProperty(property, transactionContext) {
    const { invoke: invokeRes } = transactionContext;
    let res;
    if (property?.__type === utils_1.OrchestrationUtils.SymbolInputReference) {
        res = transactionContext.payload;
    }
    else if (property?.__type === utils_1.OrchestrationUtils.SymbolMedusaWorkflowResponse) {
        res = await resolveValue(property.$result, transactionContext);
    }
    else if (property?.__type === utils_1.OrchestrationUtils.SymbolWorkflowStepTransformer) {
        res = await property.__resolver(transactionContext);
    }
    else if (property?.__type === utils_1.OrchestrationUtils.SymbolWorkflowStep) {
        const output = invokeRes[property.__step__]?.output ?? invokeRes[property.__step__];
        if (output?.__type === utils_1.OrchestrationUtils.SymbolWorkflowStepResponse) {
            res = output.output;
        }
        else {
            res = output;
        }
    }
    else if (property?.__type === utils_1.OrchestrationUtils.SymbolWorkflowStepResponse) {
        res = property.output;
    }
    else {
        res = property;
    }
    return res;
}
/**
 * @internal
 */
async function resolveValue(input, transactionContext) {
    const unwrapInput = async (inputTOUnwrap, parentRef) => {
        if (inputTOUnwrap == null) {
            return inputTOUnwrap;
        }
        if (Array.isArray(inputTOUnwrap)) {
            return await (0, utils_1.promiseAll)(inputTOUnwrap.map((i) => resolveValue(i, transactionContext)));
        }
        if (typeof inputTOUnwrap !== "object") {
            return inputTOUnwrap;
        }
        for (const key of Object.keys(inputTOUnwrap)) {
            parentRef[key] = (0, utils_1.deepCopy)(await resolveProperty(inputTOUnwrap[key], transactionContext));
            if (typeof parentRef[key] === "object") {
                parentRef[key] = await unwrapInput(parentRef[key], parentRef[key]);
            }
        }
        return parentRef;
    };
    const copiedInput = input?.__type === utils_1.OrchestrationUtils.SymbolWorkflowWorkflowData
        ? input.output
        : input;
    const result = copiedInput?.__type
        ? await resolveProperty(copiedInput, transactionContext)
        : await unwrapInput(copiedInput, {});
    const strResult = JSON.stringify(result); // Symbols return undefined
    if ((0, utils_1.isDefined)(strResult)) {
        return JSON.parse(strResult);
    }
}
//# sourceMappingURL=resolve-value.js.map