import { DistributedTransactionEvents, DistributedTransactionType, LocalWorkflow, TransactionStepError } from "@medusajs/orchestration";
import { Context, LoadedModule, MedusaContainer } from "@medusajs/types";
type BaseFlowRunOptions = {
    context?: Context;
    resultFrom?: string | string[] | Symbol;
    throwOnError?: boolean;
    logOnError?: boolean;
    events?: DistributedTransactionEvents;
    container?: LoadedModule[] | MedusaContainer;
};
export type FlowRunOptions<TData = unknown> = BaseFlowRunOptions & {
    input?: TData;
};
export type FlowRegisterStepSuccessOptions<TData = unknown> = BaseFlowRunOptions & {
    idempotencyKey: string;
    response?: TData;
};
export type FlowRegisterStepFailureOptions<TData = unknown> = BaseFlowRunOptions & {
    idempotencyKey: string;
    response?: TData;
};
export type FlowCancelOptions = {
    transaction?: DistributedTransactionType;
    transactionId?: string;
    context?: Context;
    throwOnError?: boolean;
    logOnError?: boolean;
    events?: DistributedTransactionEvents;
    container?: LoadedModule[] | MedusaContainer;
};
/**
 * The details of a workflow's execution.
 */
export type WorkflowResult<TResult = unknown> = {
    /**
     * Any errors that occured in the workflow.
     */
    errors: TransactionStepError[];
    /**
     * The transaction details of the workflow's execution.
     */
    transaction: DistributedTransactionType;
    /**
     * The result returned by the workflow.
     */
    result: TResult;
};
export type ExportedWorkflow<TData = unknown, TResult = unknown, TDataOverride = undefined, TResultOverride = undefined> = {
    run: (args?: FlowRunOptions<TDataOverride extends undefined ? TData : TDataOverride>) => Promise<WorkflowResult<TResultOverride extends undefined ? TResult : TResultOverride>>;
    registerStepSuccess: (args?: FlowRegisterStepSuccessOptions<TDataOverride extends undefined ? TData : TDataOverride>) => Promise<WorkflowResult<TResultOverride extends undefined ? TResult : TResultOverride>>;
    registerStepFailure: (args?: FlowRegisterStepFailureOptions<TDataOverride extends undefined ? TData : TDataOverride>) => Promise<WorkflowResult<TResultOverride extends undefined ? TResult : TResultOverride>>;
    cancel: (args?: FlowCancelOptions) => Promise<WorkflowResult>;
};
export type MainExportedWorkflow<TData = unknown, TResult = unknown> = {
    <TDataOverride = undefined, TResultOverride = undefined>(container?: LoadedModule[] | MedusaContainer): Omit<LocalWorkflow, "run" | "registerStepSuccess" | "registerStepFailure" | "cancel"> & ExportedWorkflow<TData, TResult, TDataOverride, TResultOverride>;
} & {
    /**
     * You can also directly call run, registerStepSuccess, registerStepFailure and cancel on the exported workflow
     */
    run<TDataOverride = undefined, TResultOverride = undefined>(args?: FlowRunOptions<TDataOverride extends undefined ? TData : TDataOverride>): Promise<WorkflowResult<TResultOverride extends undefined ? TResult : TResultOverride>>;
    registerStepSuccess<TDataOverride = undefined, TResultOverride = undefined>(args?: FlowRegisterStepSuccessOptions<TDataOverride extends undefined ? TData : TDataOverride>): Promise<WorkflowResult<TResultOverride extends undefined ? TResult : TResultOverride>>;
    registerStepFailure<TDataOverride = undefined, TResultOverride = undefined>(args?: FlowRegisterStepFailureOptions<TDataOverride extends undefined ? TData : TDataOverride>): Promise<WorkflowResult<TResultOverride extends undefined ? TResult : TResultOverride>>;
    cancel(args?: FlowCancelOptions): Promise<WorkflowResult>;
};
export {};
//# sourceMappingURL=type.d.ts.map