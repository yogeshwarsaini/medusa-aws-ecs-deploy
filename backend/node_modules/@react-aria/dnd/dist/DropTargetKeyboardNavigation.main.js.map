{"mappings":"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","sources":["packages/@react-aria/dnd/src/DropTargetKeyboardNavigation.ts"],"sourcesContent":["import {Collection, DropTarget, Key, KeyboardDelegate, Node} from '@react-types/shared';\nimport {getChildNodes} from '@react-stately/collections';\n\nexport function navigate(\n  keyboardDelegate: KeyboardDelegate,\n  collection: Collection<Node<unknown>>,\n  target: DropTarget | null | undefined,\n  direction: 'left' | 'right' | 'up' | 'down',\n  rtl = false,\n  wrap = false\n): DropTarget | null {\n  switch (direction) {\n    case 'left':\n      return rtl \n        ? nextDropTarget(keyboardDelegate, collection, target, wrap, 'left')\n        : previousDropTarget(keyboardDelegate, collection, target, wrap, 'left');\n    case 'right':\n      return rtl \n        ? previousDropTarget(keyboardDelegate, collection, target, wrap, 'right')\n        : nextDropTarget(keyboardDelegate, collection, target, wrap, 'right');\n    case 'up':\n      return previousDropTarget(keyboardDelegate, collection, target, wrap);\n    case 'down':\n      return nextDropTarget(keyboardDelegate, collection, target, wrap);\n  }\n}\n\nfunction nextDropTarget(\n  keyboardDelegate: KeyboardDelegate,\n  collection: Collection<Node<unknown>>,\n  target: DropTarget | null | undefined,\n  wrap = false,\n  horizontal: 'left' | 'right' | null = null\n): DropTarget | null {\n  if (!target) {\n    return {\n      type: 'root'\n    };\n  }\n\n  if (target.type === 'root') {\n    let nextKey = keyboardDelegate.getFirstKey?.() ?? null;\n    if (nextKey != null) {\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition: 'before'\n      };\n    }\n\n    return null;\n  }\n\n  if (target.type === 'item') {\n    let nextKey: Key | null | undefined = null;\n    if (horizontal) {\n      nextKey = horizontal === 'right' ? keyboardDelegate.getKeyRightOf?.(target.key) : keyboardDelegate.getKeyLeftOf?.(target.key);\n    } else {\n      nextKey = keyboardDelegate.getKeyBelow?.(target.key);\n    }\n    let nextCollectionKey = collection.getKeyAfter(target.key);\n\n    // If the keyboard delegate did not move to the next key in the collection,\n    // jump to that key with the same drop position. Otherwise, try the other\n    // drop positions on the current key first.\n    if (nextKey != null && nextKey !== nextCollectionKey) {\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition: target.dropPosition\n      };\n    }\n    \n    switch (target.dropPosition) {\n      case 'before': {\n        return {\n          type: 'item',\n          key: target.key,\n          dropPosition: 'on'\n        };\n      }\n      case 'on': {\n        // If there are nested items, traverse to them prior to the \"after\" position of this target.\n        // If the next key is on the same level, then its \"before\" position is equivalent to this item's \"after\" position.\n        let targetNode = collection.getItem(target.key);\n        let nextNode = nextKey != null ? collection.getItem(nextKey) : null;\n        if (targetNode && nextNode && nextNode.level >= targetNode.level) {\n          return {\n            type: 'item',\n            key: nextNode.key,\n            dropPosition: 'before'\n          };\n        }\n\n        return {\n          type: 'item',\n          key: target.key,\n          dropPosition: 'after'\n        };\n      }\n      case 'after': {\n        // If this is the last sibling in a level, traverse to the parent.\n        let targetNode = collection.getItem(target.key);        \n        if (targetNode && targetNode.nextKey == null && targetNode.parentKey != null) {\n          // If the parent item has an item after it, use the \"before\" position.\n          let parentNode = collection.getItem(targetNode.parentKey);\n          if (parentNode?.nextKey != null) {\n            return {\n              type: 'item',\n              key: parentNode.nextKey,\n              dropPosition: 'before'\n            };\n          }\n\n          if (parentNode) {\n            return {\n              type: 'item',\n              key: parentNode.key,\n              dropPosition: 'after'\n            };\n          }\n        }\n\n        if (targetNode?.nextKey != null) {\n          return {\n            type: 'item',\n            key: targetNode.nextKey,\n            dropPosition: 'on'\n          };\n        }\n      }\n    }\n  }\n\n  if (wrap) {\n    return {\n      type: 'root'\n    };\n  }\n\n  return null;\n}\n\nfunction previousDropTarget(\n  keyboardDelegate: KeyboardDelegate,\n  collection: Collection<Node<unknown>>,\n  target: DropTarget | null | undefined,\n  wrap = false,\n  horizontal: 'left' | 'right' | null = null\n): DropTarget | null {\n  // Start after the last root-level item.\n  if (!target || (wrap && target.type === 'root')) {\n    // Keyboard delegate gets the deepest item but we want the shallowest.\n    let prevKey: Key | null = null;\n    let lastKey = keyboardDelegate.getLastKey?.();\n    while (lastKey != null) {\n      prevKey = lastKey;\n      let node = collection.getItem(lastKey);\n      lastKey = node?.parentKey;\n    }\n\n    if (prevKey != null) {\n      return {\n        type: 'item',\n        key: prevKey,\n        dropPosition: 'after'\n      };\n    }\n\n    return null;\n  }\n\n  if (target.type === 'item') {\n    let prevKey: Key | null | undefined = null;\n    if (horizontal) {\n      prevKey = horizontal === 'left' ? keyboardDelegate.getKeyLeftOf?.(target.key) : keyboardDelegate.getKeyRightOf?.(target.key);\n    } else {\n      prevKey = keyboardDelegate.getKeyAbove?.(target.key);\n    }\n    let prevCollectionKey = collection.getKeyBefore(target.key);\n\n    // If the keyboard delegate did not move to the next key in the collection,\n    // jump to that key with the same drop position. Otherwise, try the other\n    // drop positions on the current key first.\n    if (prevKey != null && prevKey !== prevCollectionKey) {\n      return {\n        type: 'item',\n        key: prevKey,\n        dropPosition: target.dropPosition\n      };\n    }\n\n    switch (target.dropPosition) {\n      case 'before': {\n        // Move after the last child of the previous item.\n        let targetNode = collection.getItem(target.key);\n        if (targetNode && targetNode.prevKey != null) {\n          let lastChild = getLastChild(collection, targetNode.prevKey);\n          if (lastChild) {\n            return lastChild;\n          }\n        }\n\n        if (prevKey != null) {\n          return {\n            type: 'item',\n            key: prevKey,\n            dropPosition: 'on'\n          };\n        }\n\n        return {\n          type: 'root'\n        };\n      }\n      case 'on': {\n        return {\n          type: 'item',\n          key: target.key,\n          dropPosition: 'before'\n        };\n      }\n      case 'after': {\n        // Move after the last child of this item.\n        let lastChild = getLastChild(collection, target.key);\n        if (lastChild) {\n          return lastChild;\n        }\n\n        return {\n          type: 'item',\n          key: target.key,\n          dropPosition: 'on'\n        };\n      }\n    }\n  }\n\n  if (target.type !== 'root') {\n    return {\n      type: 'root'\n    };\n  }\n\n  return null;\n}\n\nfunction getLastChild(collection: Collection<Node<unknown>>, key: Key): DropTarget | null {\n  // getChildNodes still returns child tree items even when the item is collapsed.\n  // Checking if the next item has a greater level is a silly way to determine if the item is expanded.\n  let targetNode = collection.getItem(key);\n  let nextKey = collection.getKeyAfter(key);\n  let nextNode = nextKey != null ? collection.getItem(nextKey) : null;\n  if (targetNode && nextNode && nextNode.level > targetNode.level) {\n    let children = getChildNodes(targetNode, collection);\n    let lastChild: Node<unknown> | null = null;\n    for (let child of children) {\n      if (child.type === 'item') {\n        lastChild = child;\n      }\n    }\n\n    if (lastChild) {\n      return {\n        type: 'item',\n        key: lastChild.key,\n        dropPosition: 'after'\n      };\n    }\n  }\n\n  return null;\n}\n"],"names":[],"version":3,"file":"DropTargetKeyboardNavigation.main.js.map"}